<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="c:\program files (x86)\microsoft visual studio\2019\community\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="16.0">
 <Targets>
  <Target Name="C:\TMP\OData\ODataViewer\ODataViewer\bin\Debug\ODataViewer.exe">
   <Modules>
    <Module Name="odataviewer.exe">
     <Messages>
      <Message TypeName="AssembliesShouldHaveValidStrongNames" Category="Microsoft.Design" CheckId="CA2210" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
       <Issue Name="NoStrongName" Certainty="95" Level="CriticalError">Подпишите 'ODataViewer.exe' с использованием ключа строгого имени.</Issue>
      </Message>
      <Message TypeName="MarkAssembliesWithClsCompliant" Category="Microsoft.Design" CheckId="CA1014" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
       <Issue Certainty="95" Level="Error">Пометьте 'ODataViewer.exe' как CLSCompliant(true), поскольку он предоставляет типы, видимые извне.</Issue>
      </Message>
      <Message TypeName="MarkAssembliesWithNeutralResourcesLanguage" Category="Microsoft.Performance" CheckId="CA1824" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
       <Issue Certainty="95" Level="Warning">Так как сборка 'ODataViewer.exe' содержит файл ResX-ресурса, пометьте его атрибутом NeutralResourcesLanguage, указав язык ресурсов внутри сборки. Это может ускорить поиск ресурса при первом извлечении.</Issue>
      </Message>
     </Messages>
     <Namespaces>
      <Namespace Name="E4D">
       <Types>
        <Type Name="About" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.Format(System.String,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="11">В связи с тем, что поведение 'string.Format(string, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'About.About()' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="13">В связи с тем, что поведение 'string.Format(string, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'About.About()' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
            </Message>
            <Message Id="System.Windows.Forms.Control.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="11">Метод 'About.About()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "About ,  ".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="13">Метод 'About.About()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Version ,  ".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyCompany" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="82">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyCompany'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyCopyright" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="69">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyCopyright'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyDescription" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="43">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyDescription'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyProduct" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="56">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyProduct'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AssemblyTitle" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="24">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyTitle'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
           <Accessors>
            <Accessor Name="#get_AssemblyTitle()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
             <Messages>
              <Message TypeName="TestForEmptyStringsUsingStringLength" Category="Microsoft.Performance" CheckId="CA1820" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
               <Issue Name="IsNullOrEmpty" Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="29">Замените вызов 'string.operator !=(string, string)' в 'About.AssemblyTitle.get()' вызовом "String.IsNullOrEmpty".</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#AssemblyVersion" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.cs" Line="38">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'About.AssemblyVersion'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitializeComponent()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.Windows.Forms.Control.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="152">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;OK".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="114">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Copyright E4D Solutions LTD.".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="126">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "E4D Solutions LTD.".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="90">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "OData Viewer".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="102">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Version 2.0".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="About.designer.cs" Line="166">Метод 'About.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "www.E4D.co.il".</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="ODataViewer">
       <Types>
        <Type Name="Association" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#EndRoles" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="Association.cs" Line="7">Установите доступ к 'Association.EndRoles' только для чтения, удалив установщик свойств.</Issue>
            </Message>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="Association.cs" Line="7">Измените 'List&lt;EndRole&gt;' в 'Association.EndRoles' так, чтобы использовать Collection&lt;T&gt;, ReadOnlyCollection&lt;T&gt; или KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="DataServiceConfigForm" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#InitializeComponent()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.Windows.Forms.Control.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="DataServiceConfigForm.Designer.cs" Line="97">Метод 'DataServiceConfigForm.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "OData Path  Window".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="DataServiceConfigForm.Designer.cs" Line="84">Метод 'DataServiceConfigForm.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Please insert the OData URL".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="DataServiceConfigForm.Designer.cs" Line="68">Метод 'DataServiceConfigForm.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Save".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="DataServiceConfigForm.Designer.cs" Line="59">Метод 'DataServiceConfigForm.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Service Path:".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Forms" File="DataServiceConfigForm.Designer.cs" Line="48">Метод 'DataServiceConfigForm.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "http://services.odata.org/Northwind/Northwind.svc/".</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EDMElement" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="EDM" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="85" Level="Error">Исправьте прописные или строчные буквы строки "EDM" в имени типа 'EDMElement', изменив ее на "Edm".</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#ToString()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.Format(System.String,System.Object,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EDMElement.cs" Line="10">В связи с тем, что поведение 'string.Format(string, object, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'EDMElement.ToString()' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EndRole" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Type" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="BaseType" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EndRole.cs" Line="6">Ошибочное имя свойства 'EndRole.Type', уже существует унаследованный метод 'object.GetType()'. Переименуйте или удалите это свойство.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EntitiesTree" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#BuildEntity(System.Windows.Forms.TreeNode,ODataViewer.Entity)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="e" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="32">В методе 'EntitiesTree.BuildEntity(this TreeNode, Entity)' подберите более значимое имя для параметра 'e'.</Issue>
            </Message>
            <Message Id="System.Windows.Forms.TreeNodeCollection.Add(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="33">Метод 'EntitiesTree.BuildEntity(this TreeNode, Entity)' передает строку-литерал, как параметр "text" при вызове 'TreeNodeCollection.Add(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Keys".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="49">Метод 'EntitiesTree.BuildEntity(this TreeNode, Entity)' передает строку-литерал, как параметр "text" при вызове 'TreeNodeCollection.Add(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Navigation Properties".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="41">Метод 'EntitiesTree.BuildEntity(this TreeNode, Entity)' передает строку-литерал, как параметр "text" при вызове 'TreeNodeCollection.Add(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Properties".</Issue>
            </Message>
            <Message Id="0" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="33">В видимом извне методе 'EntitiesTree.BuildEntity(this TreeNode, Entity)' проверьте параметр 'source' перед его использованием.</Issue>
            </Message>
            <Message Id="1" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="36">В видимом извне методе 'EntitiesTree.BuildEntity(this TreeNode, Entity)' проверьте параметр 'e' перед его использованием.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildTree(System.Windows.Forms.TreeView,ODataViewer.MetaData)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.Windows.Forms.TreeNodeCollection.Add(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="21">Метод 'EntitiesTree.BuildTree(this TreeView, MetaData)' передает строку-литерал, как параметр "text" при вызове 'TreeNodeCollection.Add(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "EntitySet".</Issue>
            </Message>
            <Message Id="0" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="18">В видимом извне методе 'EntitiesTree.BuildTree(this TreeView, MetaData)' проверьте параметр 'source' перед его использованием.</Issue>
            </Message>
            <Message Id="1" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitiesTree.cs" Line="19">В видимом извне методе 'EntitiesTree.BuildTree(this TreeView, MetaData)' проверьте параметр 'metaData' перед его использованием.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Entity" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Keys" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="Entity.cs" Line="14">Установите доступ к 'Entity.Keys' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NavigationProperties" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="Entity.cs" Line="16">Установите доступ к 'Entity.NavigationProperties' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Properties" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="Entity.cs" Line="15">Установите доступ к 'Entity.Properties' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EntityContainer" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AssociationSet" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntityContainer.cs" Line="14">Установите доступ к 'EntityContainer.AssociationSet' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EntitySets" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntityContainer.cs" Line="13">Установите доступ к 'EntityContainer.EntitySets' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="EntitySet" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Entities" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="EntitySet.cs" Line="22">Установите доступ к 'EntitySet.Entities' только для чтения, удалив установщик свойств.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Expression" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.cctor()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="CriticalWarning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="8">Инициализируйте все статические поля в 'Expression' при объявлении и удалите явный статический конструктор.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType,System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="31">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "IsOf".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="23">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "and".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="31">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "contains".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="31">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "endswith".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "eq".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "gt".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "gteq".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "lt".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "lteq".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="12">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "ne".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="23">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "not".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="23">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "or".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="31">Метод 'Expression.Expression()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "startswith".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BoolFunc" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="NonConstantFieldsShouldNotBeVisible" Category="Microsoft.Usage" CheckId="CA2211" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Warning">Попробуйте сделать 'Expression.BoolFunc' не открытым или константой.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Funcs(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="103">Измените 'List&lt;IntellisenseItem&gt;' в 'Expression.Funcs(string)' так, чтобы использовать Collection&lt;T&gt;, ReadOnlyCollection&lt;T&gt; или KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FuncsToolTip(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="112">Измените 'List&lt;string&gt;' в 'Expression.FuncsToolTip(string)' так, чтобы использовать Collection&lt;T&gt;, ReadOnlyCollection&lt;T&gt; или KeyedCollection&lt;K,V&gt;</Issue>
            </Message>
            <Message Id="f" TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="MemberParameterMoreMeaningfulName" Certainty="75" Level="CriticalWarning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="112">В методе 'Expression.FuncsToolTip(string)' подберите более значимое имя для параметра 'f'.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitBoolFuncs()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="53">Метод 'Expression.InitBoolFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "contains( \'string\' , \'string\' )".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="53">Метод 'Expression.InitBoolFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "endswith( \'string\' , \'string\' )".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="53">Метод 'Expression.InitBoolFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "isof( \'expression\' , \'type\' )".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="53">Метод 'Expression.InitBoolFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "isof( \'type\' )".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="53">Метод 'Expression.InitBoolFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "startswith( \'string\' , \'string\' )".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitIntFuncs()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType,System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "day".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "hour".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "indexof".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "length".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "minute".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "month".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "second".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="67">Метод 'Expression.InitIntFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "year".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitStringFuncs()" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType,System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "concat".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "insert".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "remove".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "replace".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "substring".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "tolower".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "toupper".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="85">Метод 'Expression.InitStringFuncs()' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "trim".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LogicalGroupOperators" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="NonConstantFieldsShouldNotBeVisible" Category="Microsoft.Usage" CheckId="CA2211" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Warning">Попробуйте сделать 'Expression.LogicalGroupOperators' не открытым или константой.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LogicalOperators" Kind="Field" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="NonConstantFieldsShouldNotBeVisible" Category="Microsoft.Usage" CheckId="CA2211" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Warning">Попробуйте сделать 'Expression.LogicalOperators' не открытым или константой.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ToBitmapSource(System.Drawing.Bitmap)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="122">Рассмотрите возможность изменения типа параметра 'bitmap' в 'Expression.ToBitmapSource(this Bitmap)' с 'Bitmap' на его базовый тип 'Image'. По-видимому, данному методу для его реализации требуются только члены базового класса. Отключите вывод этого нарушения, если есть веские основания требовать, чтобы в сигнатуре метода был указан более производный тип.</Issue>
            </Message>
            <Message Id="0" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="Expression.cs" Line="125">В видимом извне методе 'Expression.ToBitmapSource(this Bitmap)' проверьте параметр 'bitmap' перед его использованием.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IntelliSense" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(ODataViewer.MetaData)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Model" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="MemberParameter" Certainty="85" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="17">В члене 'IntelliSense.IntelliSense(MetaData)' исправьте прописные или строчные буквы строки "Model" в имени параметра 'Model', изменив ее на "model".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildEntityFindMethod(ODataViewer.Entity)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="456">Возможно, у 'IntelliSense.BuildEntityFindMethod(Entity)' нет предшествующих открытых или защищенных вызывающих.</Issue>
            </Message>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="456">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'IntelliSense.BuildEntityFindMethod(Entity)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildPropertyToolTip(ODataViewer.Entity,System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="481">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'IntelliSense.BuildPropertyToolTip(Entity, string)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
            <Message Id="System.String.Format(System.String,System.Object,System.Object,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="482">В связи с тем, что поведение 'string.Format(string, object, object, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.BuildPropertyToolTip(Entity, string)' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EntitySetsIntellisense(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="123">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.EntitySetsIntellisense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="108">В связи с тем, что поведение 'string.StartsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.EntitySetsIntellisense(string)' вызовом 'string.StartsWith(string, StringComparison)'. Если результат 'string.StartsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="125">Метод 'IntelliSense.EntitySetsIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "(".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="126">Метод 'IntelliSense.EntitySetsIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "/".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="127">Метод 'IntelliSense.EntitySetsIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "?".</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="110">Метод 'IntelliSense.EntitySetsIntellisense(string)' передает строку-литерал, как параметр "value" при вызове 'IntellisenseItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$metadata".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EntitySource" Kind="Field" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="AvoidUnusedPrivateFields" Category="Microsoft.Performance" CheckId="CA1823" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning">Вероятно, поле 'IntelliSense.EntitySource' нигде не используется, или ему только присваивается значение. Используйте это поле или удалите его.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FilterIntellisense(System.String,System.String,ODataViewer.Entity)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="rightExp" TypeName="RemoveUnusedLocals" Category="Microsoft.Performance" CheckId="CA1804" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="366">'IntelliSense.FilterIntellisense(string, string, Entity)' объявляет переменную 'rightExp' типа 'string', которая никогда не используется или которой только присваивается значение. Используйте эту переменную, или удалите ее.</Issue>
            </Message>
            <Message Id="tokens" TypeName="RemoveUnusedLocals" Category="Microsoft.Performance" CheckId="CA1804" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="398">'IntelliSense.FilterIntellisense(string, string, Entity)' объявляет переменную 'tokens' типа 'string[]', которая никогда не используется или которой только присваивается значение. Используйте эту переменную, или удалите ее.</Issue>
            </Message>
            <Message Id="lastResource" TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="365">Параметр 'lastResource' в 'IntelliSense.FilterIntellisense(string, string, Entity)' никогда не используется. Удалите этот параметр или используйте его в теле метода.</Issue>
            </Message>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="401">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="425">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="431">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="System.String.IndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="373">В связи с тем, что поведение 'string.IndexOf(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.IndexOf(string, StringComparison)'. Если результат 'string.IndexOf(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="381">В связи с тем, что поведение 'string.IndexOf(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.IndexOf(string, StringComparison)'. Если результат 'string.IndexOf(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="System.String.IndexOf(System.String,System.Int32)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="382">В связи с тем, что поведение 'string.IndexOf(string, int)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.IndexOf(string, int, StringComparison)'. Если результат 'string.IndexOf(string, int, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="384">В связи с тем, что поведение 'string.IndexOf(string, int)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.FilterIntellisense(string, string, Entity)' вызовом 'string.IndexOf(string, int, StringComparison)'. Если результат 'string.IndexOf(string, int, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetIntelliSense(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="35">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.GetIntelliSense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="0#" TypeName="UriParametersShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1054" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="60" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="23">Измените тип параметра 'prefixUri' метода 'IntelliSense.GetIntelliSense(string)' со string на System.Uri или обеспечьте перегрузку метода 'IntelliSense.GetIntelliSense(string)', которая позволит передавать параметр 'prefixUri' как объект System.Uri.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="44">Метод 'IntelliSense.GetIntelliSense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="40">Метод 'IntelliSense.GetIntelliSense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "/".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="40">Метод 'IntelliSense.GetIntelliSense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "?".</Issue>
            </Message>
            <Message Id="0" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="26">В видимом извне методе 'IntelliSense.GetIntelliSense(string)' проверьте параметр 'prefixUri' перед его использованием.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#NavPropertiesIntellisense(ODataViewer.Entity,System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="206">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'IntelliSense.NavPropertiesIntellisense(Entity, string)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="220">Метод 'IntelliSense.NavPropertiesIntellisense(Entity, string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "/".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="221">Метод 'IntelliSense.NavPropertiesIntellisense(Entity, string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "?".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OperationIntellisense(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="327">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.OperationIntellisense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="System.String.StartsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="323">В связи с тем, что поведение 'string.StartsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.OperationIntellisense(string)' вызовом 'string.StartsWith(string, StringComparison)'. Если результат 'string.StartsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="291">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="290">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: ",".</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType,System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="300">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$expand=".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="349">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$filter=".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="336">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$orderby=".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="315">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$skip=".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="308">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$top=".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="329">Метод 'IntelliSense.OperationIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType, string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "desc".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PropertiesIntellisense(ODataViewer.Entity,System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="185">Метод 'IntelliSense.PropertiesIntellisense(Entity, string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "/".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="186">Метод 'IntelliSense.PropertiesIntellisense(Entity, string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "?".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ResourcesIntellisense(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="70">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.ResourcesIntellisense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="70">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.ResourcesIntellisense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="89">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntelliSense.ResourcesIntellisense(string)' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="ODataViewer.IntellisenseItem.#ctor(System.String,ODataViewer.DSType)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntelliSense.cs" Line="94">Метод 'IntelliSense.ResourcesIntellisense(string)' передает строку-литерал, как параметр "text" при вызове 'IntellisenseItem.IntellisenseItem(string, DSType)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "$value".</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IntellisenseItem" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Type" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="BaseType" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntellisenseItem.cs" Line="30">Ошибочное имя свойства 'IntellisenseItem.Type', уже существует унаследованный метод 'object.GetType()'. Переименуйте или удалите это свойство.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="IntellisenseWPFControl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="WPF" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="85" Level="Error">Исправьте прописные или строчные буквы строки "WPF" в имени типа 'IntellisenseWPFControl', изменив ее на "Wpf".</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#GetSelectedIntelliSense()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntellisenseWPFControl.xaml.cs" Line="111">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntellisenseWPFControl.GetSelectedIntelliSense()' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message Id="System.String.LastIndexOf(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntellisenseWPFControl.xaml.cs" Line="101">В связи с тем, что поведение 'string.LastIndexOf(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'IntellisenseWPFControl.GetSelectedIntelliSense()' вызовом 'string.LastIndexOf(string, StringComparison)'. Если результат 'string.LastIndexOf(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
            </Message>
            <Message TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntellisenseWPFControl.xaml.cs" Line="88">Замените 'IntellisenseWPFControl.GetSelectedIntelliSense()' свойством, если это уместно.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ShowIntelliSense(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="prefix" TypeName="VariableNamesShouldNotMatchFieldNames" Category="Microsoft.Maintainability" CheckId="CA1500" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Intellisense" File="IntellisenseWPFControl.xaml.cs" Line="66">Параметр 'prefix', объявленный в 'IntellisenseWPFControl.ShowIntelliSense(string)', и поле экземпляра типа имеют одно и то же имя. Измените имя одного из этих элементов.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="JsonExtensions" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DescendantPropertyValues(System.Text.Json.JsonElement)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotNestGenericTypesInMemberSignatures" Category="Microsoft.Design" CheckId="CA1006" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalError" Path="C:\TMP\OData\ODataViewer\ODataViewer\Extensions" File="JsonExtensions.cs" Line="47">Рассмотрите вариант проектирования, когда 'JsonExtensions.DescendantPropertyValues(this JsonElement)' не использует вложенный универсальный тип 'IEnumerable&lt;ValueTuple&lt;string, JsonElement&gt;&gt;'.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DescendantPropertyValues(System.Text.Json.JsonElement,System.Predicate`1&lt;System.String&gt;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="NoArguments" Certainty="95" Level="CriticalError" Path="C:\TMP\OData\ODataViewer\ODataViewer\Extensions" File="JsonExtensions.cs" Line="24">Вызывайте конструктор 'ArgumentNullException', который содержит сообщение и/или параметр paramName.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DescendantPropertyValues(System.Text.Json.JsonElement,System.String,System.StringComparison)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DefaultParametersShouldNotBeUsed" Category="Microsoft.Design" CheckId="CA1026" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\Extensions" File="JsonExtensions.cs" Line="11">Замените метод 'JsonExtensions.DescendantPropertyValues(this JsonElement, string, StringComparison)' его перегрузкой, предоставляющей все аргументы по умолчанию.</Issue>
            </Message>
            <Message TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="NoArguments" Certainty="95" Level="CriticalError" Path="C:\TMP\OData\ODataViewer\ODataViewer\Extensions" File="JsonExtensions.cs" Line="14">Вызывайте конструктор 'ArgumentNullException', который содержит сообщение и/или параметр paramName.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MetaData" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="TypeNamesShouldNotMatchNamespaces" Category="Microsoft.Naming" CheckId="CA1724" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
           <Issue Name="System" Certainty="95" Level="Error">Имя типа 'MetaData' вступает в конфликт полностью или частично с именем пространства имен "System.Runtime.Remoting.Metadata", определенным в .NET Framework. Переименуйте тип, чтобы устранить конфликт.</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#.ctor(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="Service" TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Name="MemberParameter" Certainty="85" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="26">В члене 'MetaData.MetaData(string)' исправьте прописные или строчные буквы строки "Service" в имени параметра 'ServiceUrl', изменив ее на "service".</Issue>
            </Message>
            <Message Id="0#" TypeName="UriParametersShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1054" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="60" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="26">Измените тип параметра 'ServiceUrl' метода 'MetaData.MetaData(string)' со string на System.Uri или обеспечьте перегрузку метода 'MetaData.MetaData(string)', которая позволит передавать параметр 'ServiceUrl' как объект System.Uri.</Issue>
            </Message>
            <Message TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="29">В методе 'MetaData.MetaData(string)' объект 'new WebClient()' не уничтожается во всех возможных путях исключений. Следует вызвать метод System.IDisposable.Dispose для объекта 'new WebClient()' до того, как все ссылки на него будут находиться вне области действия.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildEntityKeys(ODataViewer.Entity,System.Xml.Linq.XElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="163">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'MetaData.BuildEntityKeys(Entity, XElement)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildEntityNavigationProperties(ODataViewer.Entity,System.Xml.Linq.XElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="FromRole" TypeName="RemoveUnusedLocals" Category="Microsoft.Performance" CheckId="CA1804" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="187">'MetaData.BuildEntityNavigationProperties(Entity, XElement)' объявляет переменную 'FromRole' типа 'string', которая никогда не используется или которой только присваивается значение. Используйте эту переменную, или удалите ее.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BuildEntityProperties(ODataViewer.Entity,System.Xml.Linq.XElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="144">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'MetaData.BuildEntityProperties(Entity, XElement)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#proxy_OpenReadCompleted(System.Object,System.Net.OpenReadCompletedEventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="CriticalError" Path="C:\TMP\OData\ODataViewer\ODataViewer\MetaData" File="MetaData.cs" Line="52">Измените 'MetaData.proxy_OpenReadCompleted(object, OpenReadCompletedEventArgs)' так, чтобы перехватывались более специфические, чем 'Exception', исключения, либо обеспечьте повторное порождение исключения.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Property" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message Id="Property" TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
           <Issue Name="Type" Certainty="95" Level="Error">Переименуйте тип 'Property' так, чтобы он больше не находился в конфликте с зарезервированным ключевым словом языка "Property". Использование зарезервированного ключевого слова как имени типа затрудняет применение данного типа для потребителей с другими языками.</Issue>
          </Message>
         </Messages>
        </Type>
        <Type Name="RecursiveEnumerableExtensions" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Traverse`1(!!0,System.Func`2&lt;!!0,System.Collections.Generic.IEnumerable`1&lt;!!0&gt;&gt;,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DefaultParametersShouldNotBeUsed" Category="Microsoft.Design" CheckId="CA1026" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="Error">Замените метод 'RecursiveEnumerableExtensions.Traverse&lt;T&gt;(T, Func&lt;T, IEnumerable&lt;T&gt;&gt;, bool)' его перегрузкой, предоставляющей все аргументы по умолчанию.</Issue>
            </Message>
            <Message TypeName="DoNotNestGenericTypesInMemberSignatures" Category="Microsoft.Design" CheckId="CA1006" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalError">Рассмотрите вариант проектирования, когда 'RecursiveEnumerableExtensions.Traverse&lt;T&gt;(T, Func&lt;T, IEnumerable&lt;T&gt;&gt;, bool)' не использует вложенный универсальный тип 'Func&lt;T, IEnumerable&lt;T&gt;&gt;'.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ReflectionDynamicObject" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#TryGetMember(System.Dynamic.GetMemberBinder,System.Object&amp;)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="0" TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer\Extensions" File="ReflectionDynamicObject.cs" Line="14">В видимом извне методе 'ReflectionDynamicObject.TryGetMember(GetMemberBinder, out object)' проверьте параметр 'binder' перед его использованием.</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Shell" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="33">В методе 'Shell.Shell()' объект 'new WebClient()' не уничтожается во всех возможных путях исключений. Следует вызвать метод System.IDisposable.Dispose для объекта 'new WebClient()' до того, как все ссылки на него будут находиться вне области действия.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#aboutToolStripMenuItem1_Click(System.Object,System.EventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="NonExceptionEdge" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="347">В методе 'Shell.aboutToolStripMenuItem1_Click(object, EventArgs)' вызовите System.IDisposable.Dispose для объекта 'new About()' перед тем, как все ссылки на него будут вне области видимости.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message Id="httpClient" TypeName="DisposableFieldsShouldBeDisposed" Category="Microsoft.Usage" CheckId="CA2213" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="15">'Shell' содержит поле 'Shell.httpClient' типа IDisposable: 'HttpClient'. Замените метод Dispose для 'Shell' на вызов Dispose или Close по этому полю.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FullPath" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_FullPath()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message Id="System.String.Format(System.String,System.Object,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
               <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="94">В связи с тем, что поведение 'string.Format(string, object, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'Shell.FullPath.get()' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
              </Message>
              <Message Id="System.String.EndsWith(System.String)" TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="89">В связи с тем, что поведение 'string.EndsWith(string)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'Shell.FullPath.get()' вызовом 'string.EndsWith(string, StringComparison)'. Если результат 'string.EndsWith(string, StringComparison)' будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#InitializeComponent()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.Windows.Forms.Control.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="264">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Go".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="187">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "MetaData".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="589">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "OData Viewer".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="230">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Qurey Result in Grid".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="209">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Qurey Result".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="277">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Qurey:".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="553">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Tooltip".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="568">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "elementHost1".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="291">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "menuStrip1".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="532">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "statusStrip1".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="476">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'Control.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "toolStrip1".</Issue>
            </Message>
            <Message Id="System.Windows.Forms.ToolStripItem.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="459">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;About".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="493">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Copy Service Full URL".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="433">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Copy".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="396">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Edit".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="308">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;File".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="484">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;New Service".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="317">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;New".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="327">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Open".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="442">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Paste".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="361">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Print".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="410">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Redo".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="341">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Save".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="511">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Show Intellisense".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="403">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "&amp;Undo".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="151">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Collapse".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="424">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Cu&amp;t".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="380">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "E&amp;xit".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="144">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Expand All".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="502">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Open Web Browser".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="369">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Print Pre&amp;view".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="347">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Save &amp;As".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="453">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Select &amp;All".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.Designer.cs" Line="520">Метод 'Shell.InitializeComponent()' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Show Metadata Tree".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IntellisenseToolTip" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="Breaking">
             <Issue Certainty="90" Level="Error">Так как поле 'Shell.IntellisenseToolTip' является видимым извне объявляющего его типа, необходимо изменить уровень доступа на частный и добавить свойство, имеющее тот же уровень доступа, что и поле, чтобы обеспечить доступ к нему.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OpenDataServiceConfigForm()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.Format(System.String,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="320">В связи с тем, что поведение 'string.Format(string, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'Shell.OpenDataServiceConfigForm()' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PopulateDataTableFromJSON(System.String)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="174">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'Shell.PopulateDataTableFromJSON(string)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
            <Message TypeName="SetLocaleForDataTypes" Category="Microsoft.Globalization" CheckId="CA1306" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="175">Обязательно задавайте значение свойства Locale DataTable каждый раз, когда 'Shell.PopulateDataTableFromJSON(string)' создает экземпляр этого типа.</Issue>
            </Message>
            <Message TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="175">В методе 'Shell.PopulateDataTableFromJSON(string)' объект 'dt' не уничтожается во всех возможных путях исключений. Следует вызвать метод System.IDisposable.Dispose для объекта 'dt' до того, как все ссылки на него будут находиться вне области действия.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PopulateDataTableFromXML(System.Xml.Linq.XElement)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="220">Параметр "this" ("Me" в Visual Basic) никогда не используется в 'Shell.PopulateDataTableFromXML(XElement)'. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Issue>
            </Message>
            <Message TypeName="SetLocaleForDataTypes" Category="Microsoft.Globalization" CheckId="CA1306" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Certainty="90" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="221">Обязательно задавайте значение свойства Locale DataTable каждый раз, когда 'Shell.PopulateDataTableFromXML(XElement)' создает экземпляр этого типа.</Issue>
            </Message>
            <Message TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="ExceptionEdge" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="221">В методе 'Shell.PopulateDataTableFromXML(XElement)' объект 'dt' не уничтожается во всех возможных путях исключений. Следует вызвать метод System.IDisposable.Dispose для объекта 'dt' до того, как все ссылки на него будут находиться вне области действия.</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ShowMetadataTree_Click(System.Object,System.EventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.Windows.Forms.ToolStripItem.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="379">Метод 'Shell.ShowMetadataTree_Click(object, EventArgs)' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Hide Metadata Tree".</Issue>
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="384">Метод 'Shell.ShowMetadataTree_Click(object, EventArgs)' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "Show Metadata Tree".</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#txbQuery_TextChanged(System.Object,System.EventArgs)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="System.String.Format(System.String,System.Object,System.Object)" TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="NonBreaking">
             <Issue Name="IFormatProviderAlternateString" Certainty="95" Level="Error" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="100">В связи с тем, что поведение 'string.Format(string, object, object)' может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в 'Shell.txbQuery_TextChanged(object, EventArgs)' вызовом 'string.Format(IFormatProvider, string, params object[])'. Если результат 'string.Format(IFormatProvider, string, params object[])' базируется на пользовательском вводе, укажите 'CultureInfo.CurrentCulture' в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать 'CultureInfo.InvariantCulture'.</Issue>
            </Message>
            <Message Id="System.Windows.Forms.ToolStripItem.set_Text(System.String)" TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303" Status="Active" Created="2021-07-14 14:07:25Z" FixCategory="DependsOnFix">
             <Issue Name="KnownValue" Certainty="75" Level="Warning" Path="C:\TMP\OData\ODataViewer\ODataViewer" File="Shell.cs" Line="100">Метод 'Shell.txbQuery_TextChanged(object, EventArgs)' передает строку-литерал, как параметр "value" при вызове 'ToolStripItem.Text.set(string)'. Вместо этого выполните поиск следующей строки (строк) в таблице источника: "/".</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="AssembliesShouldHaveValidStrongNames" Category="Microsoft.Design" CheckId="CA2210">
   <Name>Сборки должны иметь допустимые строгие имена</Name>
   <Description>Либо строгое имя у сборки отсутствует или недействительно, либо действительность строгого имени зависит от конфигурации компьютера. В этом состоянии не следует выполнять развертывание сборки. Наиболее общие причины этого: 1). После подписания содержимое сборки было изменено. 2). Сбой в процессе подписания. 3). Сборка была подписана с задержкой. 4). В реестре существует раздел, разрешивший успешное выполнение проверки (чего не было бы в противном случае).</Description>
   <Resolution Name="NoStrongName">Подпишите {0} с использованием ключа строгого имени.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182127.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811">
   <Name>Избегайте невызываемого частного кода</Name>
   <Description>Имеется невызываемый код, не видимый извне и не являющийся известной точкой входа во время выполнения. Если это нарушение выведено ошибочно, отправьте отчет об ошибке в группу Code Analysis Visual Studio.</Description>
   <Resolution Name="Default">Возможно, у {0} нет предшествующих открытых или защищенных вызывающих.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182264.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="AvoidUnusedPrivateFields" Category="Microsoft.Performance" CheckId="CA1823">
   <Name>Избегайте неиспользуемых частных полей</Name>
   <Description>В сборке обнаружены частные поля, к которым не осуществляется доступ. Если это сообщение об этом нарушении выводится по ошибке, отправьте отчет о нем в группу Code Analysis Visual Studio.</Description>
   <Resolution Name="Default">Вероятно, поле {0} нигде не используется, или ему только присваивается значение. Используйте это поле или удалите его.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms245042.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="CollectionPropertiesShouldBeReadOnly" Category="Microsoft.Usage" CheckId="CA2227">
   <Name>Свойства, возвращающие коллекции, должны быть доступны только для чтения</Name>
   <Description>Свойства, возвращающие коллекции, должны быть доступны только для чтения, чтобы пользователи не могли полностью заменить резервное хранилище. Пользователи все же могут изменить содержимое коллекции вызовом соответствующих методов для коллекции. Отметьте, что класс XmlSerializer имеет специальную поддержку для десериализации коллекций только для чтения. Дополнительные сведения см. в обзоре XmlSerializer.</Description>
   <Resolution Name="Default">Установите доступ к {0} только для чтения, удалив установщик свойств.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182327.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="ConsiderPassingBaseTypesAsParameters" Category="Microsoft.Design" CheckId="CA1011">
   <Name>Попробуйте передать базовые типы в качестве параметров</Name>
   <Description>Применение базовых типов в качестве параметров методов повышает возможность повторного использования этих методов, если свойства методов используются только из базового класса параметра. Например, используйте Stream вместо FileStream в качестве параметра при вызове только Stream.Read(), это обеспечит работу метода со всеми типами потоков, а не только с файловыми потоками.</Description>
   <Resolution Name="Default">Рассмотрите возможность изменения типа параметра {0} в {1} с {2} на его базовый тип {3}. По-видимому, данному методу для его реализации требуются только члены базового класса. Отключите вывод этого нарушения, если есть веские основания требовать, чтобы в сигнатуре метода был указан более производный тип.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/3hk32yyz.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DefaultParametersShouldNotBeUsed" Category="Microsoft.Design" CheckId="CA1026">
   <Name>Не следует использовать параметры по умолчанию</Name>
   <Description>Некоторые языки программирования не поддерживают параметры по умолчанию. Замените параметры по умолчанию перегрузкой методов, предоставляющих аргумент по умолчанию.</Description>
   <Resolution Name="Default">Замените метод {0} его перегрузкой, предоставляющей все аргументы по умолчанию.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182135.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DisposableFieldsShouldBeDisposed" Category="Microsoft.Usage" CheckId="CA2213">
   <Name>Следует высвобождать высвобождаемые поля</Name>
   <Description>Если типу, реализующему IDisposable, принадлежат поля, которые также реализуют IDisposable, реализация Dispose() инкапсулирующего типа должна вызывать Dispose() по каждому высвобождаемому полю.</Description>
   <Resolution Name="Default">{0} содержит поле {1} типа IDisposable: {2}. Замените метод Dispose для {0} на вызов Dispose или Close по этому полю.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182328.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotCatchGeneralExceptionTypes" Category="Microsoft.Design" CheckId="CA1031">
   <Name>Не перехватывайте типы общих исключений</Name>
   <Description>Не следует перехватывать исключения типа Exception или SystemException. Перехватывание исключений общего назначения может скрыть от пользователя библиотеки ошибки времени выполнения и осложнить процесс отладки. Перехватывать следует только те исключения, которые вы можете правильно обработать.</Description>
   <Resolution Name="Default">Измените {0} так, чтобы перехватывались более специфические, чем {1}, исключения, либо обеспечьте повторное порождение исключения.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182137.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotDeclareVisibleInstanceFields" Category="Microsoft.Design" CheckId="CA1051">
   <Name>Не объявляйте видимые поля экземпляров</Name>
   <Description>Поля экземпляров, видимые вне типа, в котором они объявлены, ограничивают возможность изменения сведений о реализации, относящихся к этим элементам данных. Вместо этого используйте свойства. Они не влияют на удобство использования или производительность, но обеспечивают гибкость, скрывая сведения о реализации для используемых данных.</Description>
   <Resolution Name="Default">Так как поле {0} является видимым извне объявляющего его типа, необходимо изменить уровень доступа на частный и добавить свойство, имеющее тот же уровень доступа, что и поле, чтобы обеспечить доступ к нему.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182141.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotExposeGenericLists" Category="Microsoft.Design" CheckId="CA1002">
   <Name>Не предоставляйте универсальные списки</Name>
   <Description>Не предоставляйте List&lt;T&gt; в объектных моделях. Вместо этого используйте Collection&lt;T&gt;, ReadOnlyCollection&lt;T&gt; или KeyedCollection&lt;K,V&gt;. List&lt;T&gt; предназначен для использования из реализации, но не в API объектной модели. List&lt;T&gt; оптимизирован с точки зрения производительности, но за счет более длительного отслеживания версий. Например, если вы возвратите List&lt;T&gt; в клиентский код, то никогда не сможете получить уведомление, когда клиентский код изменит коллекцию.</Description>
   <Resolution Name="Default">Измените {0} в {1} так, чтобы использовать Collection&lt;T&gt;, ReadOnlyCollection&lt;T&gt; или KeyedCollection&lt;K,V&gt;</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182142.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotNestGenericTypesInMemberSignatures" Category="Microsoft.Design" CheckId="CA1006">
   <Name>Не создавайте вложенных универсальных типов в сигнатурах членов</Name>
   <Description>Не используйте API, который требует от пользователей создавать экземпляры универсального типа, у которых аргументом типа служит другой универсальный тип. Синтаксис становится слишком сложным.</Description>
   <Resolution Name="Default">Рассмотрите вариант проектирования, когда {0} не использует вложенный универсальный тип {1}.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182144.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldBeCasedCorrectly" Category="Microsoft.Naming" CheckId="CA1709">
   <Name>Идентификаторы должны иметь правильное сочетание прописных и строчных букв</Name>
   <Description>Идентификаторы типа, пространства имен и членов следуют стилю имен Pascal, а идентификаторы параметров используют "верблюжий" (camel) стиль имен. Двухсимвольный акроним в этих идентификаторах должен записываться прописными буквами, например, System.IO вместо System.Io. Трех- или более символьные акронимы должны следовать стилю Pascal, например, System.Xml вместо System.XML. По соглашению о стиле имен Pascal в составных словах прописной буквой выделяется первая буква каждого слова, например BackColor. По соглашению о "верблюжьем" стиле имен первая буква первого слова будет строчной, а первые буквы всех последующих слов будут прописными, например backgroundColor. Хотя на практике некоторые двухбуквенные акронимы часто не содержат две прописные буквы, правило остается в силе. Например, часто пишут "DbConnection", но это неправильно; пишите "DBConnection". Нарушение этого правила могло бы потребоваться для совместимости с существующими неуправляемыми схемами символов. В общем случае эти символы не должны быть видимы вне использующей их сборки.</Description>
   <Resolution Name="MemberParameter">В члене {0} исправьте прописные или строчные буквы строки "{1}" в имени параметра {2}, изменив ее на "{3}".</Resolution>
   <Resolution Name="Type">Исправьте прописные или строчные буквы строки "{0}" в имени типа {1}, изменив ее на "{2}".</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182240.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="85">Error</MessageLevel>
   <File Name="namingrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldBeSpelledCorrectly" Category="Microsoft.Naming" CheckId="CA1704">
   <Name>Идентификаторы должны иметь правильное правописание</Name>
   <Description>Отдельные слова, составляющие идентификатор, не должны быть сокращены и должны быть написаны без орфографических ошибок. Если это правило создает ложный положительный результат для термина, который должен распознаваться, добавьте термин в пользовательский словарь FxCop.</Description>
   <Resolution Name="MemberParameterMoreMeaningfulName">В методе {0} подберите более значимое имя для параметра {1}.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb264492.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalWarning</MessageLevel>
   <File Name="namingrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="IdentifiersShouldNotMatchKeywords" Category="Microsoft.Naming" CheckId="CA1716">
   <Name>Идентификаторы не должны совпадать с ключевыми словами</Name>
   <Description>Идентификаторы, вступающие в конфликт с зарезервированными ключевыми словами языка, не должны использоваться. Использование зарезервированного ключевого слова в качестве идентификатора затрудняет использование данного API в других языках.</Description>
   <Resolution Name="Type">Переименуйте тип {0} так, чтобы он больше не находился в конфликте с зарезервированным ключевым словом языка "{1}". Использование зарезервированного ключевого слова как имени типа затрудняет применение данного типа для потребителей с другими языками.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182248.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="InitializeReferenceTypeStaticFieldsInline" Category="Microsoft.Performance" CheckId="CA1810">
   <Name>Инициализируйте статические поля ссылочных типов при объявлении</Name>
   <Description>Статические поля должны быть инициализированы при объявлении. Инициализация статических данных в явных статических конструкторах понижает производительность кода.</Description>
   <Resolution Name="Default">Инициализируйте все статические поля в {0} при объявлении и удалите явный статический конструктор.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182275.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">CriticalWarning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="InstantiateArgumentExceptionsCorrectly" Category="Microsoft.Usage" CheckId="CA2208">
   <Name>Правильно создавайте экземпляры исключений аргументов</Name>
   <Description>Строковые аргументы, передаваемые конструкторам ArgumentException и производных типов, должны быть правильными. Типы, производные от ArgumentException, имеют несовместимые перегрузки конструктора в отношении сообщению и параметрам paramName по сравнению с ArgumentException.</Description>
   <Resolution Name="NoArguments">Вызывайте конструктор {0}, который содержит сообщение и/или параметр paramName.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182347.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalError</MessageLevel>
   <File Name="usagerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="MarkAssembliesWithClsCompliant" Category="Microsoft.Design" CheckId="CA1014">
   <Name>Пометьте сборки атрибутом CLSCompliantAttribute</Name>
   <Description>Сборки должны явно объявлять о своей CLS-совместимости при помощи атрибута CLSCompliant. Сборка без этого атрибута не является CLS-совместимой. Сборки, модули и типы могут быть CLS-совместимыми, даже если некоторые их части не являются CLS-совместимыми. Применимы следующие правила: 1). Если элемент помечен как CLSCompliant, все его несовместимые члены должны иметь атрибут CLSCompliant, аргументу которого установлено значение False. 2). Каждый CLS-несовместимый член должен быть дополнен сравнимым CLS-совместимым альтернативным членом.</Description>
   <Resolution Name="Default">Пометьте {0} как CLSCompliant(true), поскольку он предоставляет типы, видимые извне.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182156.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="MarkAssembliesWithNeutralResourcesLanguage" Category="Microsoft.Performance" CheckId="CA1824">
   <Name>Помечайте сборки атрибутом NeutralResourcesLanguageAttribute</Name>
   <Description>Атрибут NeutralResourcesLanguage оповещает ResourceManager о языке, используемом для объявления в сборке ресурсов, нейтральных по языку и региональным параметрам. При поиске ресурсов с теми же языком и региональными параметрами, что и нейтральные по языку ресурсы, ResourceManager автоматически использует ресурсы, расположенные в основной сборке, и не ищет вспомогательную сборку с текущими языком и региональными параметрами интерфейса пользователя для текущего потока. Это улучшает поиск первого загруженного ресурса и может уменьшить рабочие наборы.</Description>
   <Resolution Name="Default">Так как сборка {0} содержит файл ResX-ресурса, пометьте его атрибутом NeutralResourcesLanguage, указав язык ресурсов внутри сборки. Это может ускорить поиск ресурса при первом извлечении.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb385967.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="MarkMembersAsStatic" Category="Microsoft.Performance" CheckId="CA1822">
   <Name>Пометьте члены как статические</Name>
   <Description>Методы, которые не обращаются к данным экземпляров и не вызывают методы экземпляров, могут быть определены как статические (Shared в Visual Basic). После этого компилятор создаст невиртуальные места для вызова этих членов, что предотвратит во время выполнения проверку для каждого вызова, что текущий указатель на объект не имеет значения NULL. Это может привести к ощутимому росту производительности для требовательных к производительности кодов. В некоторых случаях ошибка доступа к текущему экземпляру объекта указывает на проблемы с правильностью кода.</Description>
   <Resolution Name="Default">Параметр "this" ("Me" в Visual Basic) никогда не используется в {0}. Пометьте член как static (или Shared в среде Visual Basic) либо используйте "this" или "Me" в теле метода или хотя бы в одном методе доступа к свойству.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms245046.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="NonConstantFieldsShouldNotBeVisible" Category="Microsoft.Usage" CheckId="CA2211">
   <Name>Поля, не являющиеся константами, не должны быть видимыми</Name>
   <Description>Статические поля должны быть константами, если только вы не управляете тщательно доступом к полям с помощью блокировок. Использование статических переменных, если не сделать их потокобезопасными, может представлять угрозу состоянию выполнения. Это правило применяется к библиотекам управляемого кода. Если анализируемая сборка является приложением, обычно безопасно исключить нарушения этого правила.</Description>
   <Resolution Name="Default">Попробуйте сделать {0} не открытым или константой.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182353.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="PropertyNamesShouldNotMatchGetMethods" Category="Microsoft.Naming" CheckId="CA1721">
   <Name>Имена свойств не должны совпадать с именами методов get</Name>
   <Description>Обнаружен метод Get с тем же самым именем, что и свойство. Методы Get и свойства должны иметь имена, явно различающие их функции. Информацию о приоритетах свойств и методов можно найти в руководстве разработчика.</Description>
   <Resolution Name="BaseType">Ошибочное имя свойства {0}, уже существует унаследованный метод {1}. Переименуйте или удалите это свойство.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182253.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="RemoveUnusedLocals" Category="Microsoft.Performance" CheckId="CA1804">
   <Name>Удалите неиспользуемые локальные переменные</Name>
   <Description>Удалите локальные переменные, которые не используются или которым только присваиваются значения в реализациях методов.</Description>
   <Resolution Name="Default">{0} объявляет переменную {1} типа {2}, которая никогда не используется или которой только присваивается значение. Используйте эту переменную, или удалите ее.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182278.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="ReviewUnusedParameters" Category="Microsoft.Usage" CheckId="CA1801">
   <Name>Проверьте неиспользуемые параметры</Name>
   <Description>Проверьте параметры в не-виртуальных методах, не используемые в теле метода, и убедитесь, что отсутствие доступа к ним не нарушает правильность кода. Неиспользуемые параметры влекут издержки производительности и обслуживания. Иногда нарушение этого правила может указывать на ошибку в реализации метода (т.е. параметр в действительности должен использоваться в теле метода). Исключите предупреждения этого правила, если параметр должен существовать из-за совместимости с предыдущими версиями.</Description>
   <Resolution Name="Default">Параметр {0} в {1} никогда не используется. Удалите этот параметр или используйте его в теле метода.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182268.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="usagerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="SetLocaleForDataTypes" Category="Microsoft.Globalization" CheckId="CA1306">
   <Name>Задавайте языковой стандарт для типов данных</Name>
   <Description>В большинстве случаев значение Locale должно быть явно задано как CultureInfo.InvariantCulture для экземпляров DataSet и DataTable. При создании экземпляров DataSet или DataTable для Locale задается значение, соответствующее текущему языку и региональным настройкам. В большинстве случаев для Locale следует задать значение CultureInfo.InvariantCulture, чтобы обеспечить верное поведение при сортировке для любых языков и региональных настроек.</Description>
   <Resolution Name="Default">Обязательно задавайте значение свойства Locale {0} каждый раз, когда {1} создает экземпляр этого типа.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182188.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyIFormatProvider" Category="Microsoft.Globalization" CheckId="CA1305">
   <Name>Указывайте IFormatProvider</Name>
   <Description>Если существует перегрузка, которая принимает аргумент IFormatProvider, следует всегда вызывать ее, а не другую перегрузку, не принимающую этот аргумент. Некоторые методы во время выполнения преобразовывают значение в представление строки или из него. Они принимают строковый параметр, который содержит один или несколько знаков, которые называются спецификаторами формата и указывают, как следует преобразовывать значение. Если смысл спецификатора формата зависит от языка и региональных настроек, форматируемый объект предоставляет действительные символы, которые используются в представлении строки. В сценариях, в которых поведение при сортировке и сравнении не зависит от языка и региональных настроек, следует указать CultureInfo.InvariantCulture, в ином случае следует указывать CultureInfo.CurrentCulture.</Description>
   <Resolution Name="IFormatProviderAlternateString">В связи с тем, что поведение {0} может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в {1} вызовом {2}. Если результат {2} базируется на пользовательском вводе, укажите {3} в качестве параметра "IformatProvider". В ином случае, если результат будет храниться и использоваться программой, например при сохранении на диск или в базу данных, следует указать {4}.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182190.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyStringComparison" Category="Microsoft.Globalization" CheckId="CA1307">
   <Name>Указывайте StringComparison</Name>
   <Description>Если существует перегрузка, которая принимает аргумент StringComparison, следует вызвать ее, а не другую перегрузку, не принимающую этот аргумент.</Description>
   <Resolution Name="Default">В связи с тем, что поведение {0} может изменяться в зависимости от языка и региональных настроек текущего пользователя, следует заменить этот вызов в {1} вызовом {2}. Если результат {2} будет отображаться для пользователя, например, при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких, как пути к файлам, переменные окружения или ключи и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386080.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="TestForEmptyStringsUsingStringLength" Category="Microsoft.Performance" CheckId="CA1820">
   <Name>Проверяйте наличие пустых строк, используя длину строки</Name>
   <Description>Для определения пустой строки проверьте, равно ли ее свойство String.Length нулю. Использование таких конструкций, как ".Equals(строка) и String.Empty.Equals(строка) менее эффективно, чем проверка длины строки. Замените их проверками "Строка".Length == 0.</Description>
   <Resolution Name="IsNullOrEmpty">Замените вызов {0} в {1} вызовом "String.IsNullOrEmpty".</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182279.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="TypeNamesShouldNotMatchNamespaces" Category="Microsoft.Naming" CheckId="CA1724">
   <Name>Имена типов не должны совпадать с именами пространства имен</Name>
   <Description>Не используйте идентификаторы, вступающие полностью или частично в конфликт с именами пространства имен. Отдавайте предпочтение именам, описывающим назначение или содержание типа.</Description>
   <Resolution Name="System">Имя типа {0} вступает в конфликт полностью или частично с именем пространства имен "{1}", определенным в .NET Framework. Переименуйте тип, чтобы устранить конфликт.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182257.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="namingrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="UriParametersShouldNotBeStrings" Category="Microsoft.Design" CheckId="CA1054">
   <Name>Параметры URI не должны быть строками</Name>
   <Description>Если имя параметра содержит комбинацию символов "uri", "url" или "urn", и он имеет строковый тип, необходимо изменить тип параметра на System.Uri, если не существует перегруженный метод, в котором тот же параметр имеет тип System.Uri.</Description>
   <Resolution Name="Default">Измените тип параметра {0} метода {1} со string на System.Uri или обеспечьте перегрузку метода {1}, которая позволит передавать параметр {0} как объект System.Uri.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182174.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="60">Error</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="UsePropertiesWhereAppropriate" Category="Microsoft.Design" CheckId="CA1024">
   <Name>Используйте свойства, если это уместно</Name>
   <Description>В большинстве случаев вместо методов Get или Set следует использовать свойства. Методы как альтернативу свойствам предпочтительнее использовать в следующих ситуациях: операция предусматривает преобразование, потребляет много ресурсов или сопровождается заметным побочным эффектом; важен порядок выполнения; член, вызванный дважды подряд, выдает различные результаты; статический член возвращает меняющееся значение; член возвращает массив.</Description>
   <Resolution Name="Default">Замените {0} свойством, если это уместно.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182181.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="designrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="VariableNamesShouldNotMatchFieldNames" Category="Microsoft.Maintainability" CheckId="CA1500">
   <Name>Имена переменных не должны совпадать с именами полей</Name>
   <Description>Имена полей экземпляра и имена переменных не должны совпадать внутри одной области.</Description>
   <Resolution Name="Parameter">Параметр {0}, объявленный в {1}, и поле экземпляра типа имеют одно и то же имя. Измените имя одного из этих элементов.</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182216.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="maintainabilityrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="Ликвидировать объекты перед потерей области" Category="Microsoft.Reliability" CheckId="CA2000">
   <Name>Ликвидировать объекты перед потерей области</Name>
   <Description>Если освобождаемый объект не высвобождается явно до того, как все ссылки на него оказываются вне области имен, объект будет высвобожден в некоторый заранее не определенный момент, когда сборщик мусора запустит завершающий метод объекта. Так как может возникнуть событие исключения, препятствующее выполнению метода завершения объекта, объект будет ликвидирован в явной форме.</Description>
   <Resolution Name="ExceptionEdge">В методе {0} объект {1} не уничтожается во всех возможных путях исключений. Следует вызвать метод System.IDisposable.Dispose для объекта {1} до того, как все ссылки на него будут находиться вне области действия.</Resolution>
   <Resolution Name="NonExceptionEdge">В методе {0} вызовите System.IDisposable.Dispose для объекта {1} перед тем, как все ссылки на него будут вне области видимости.</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182289.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="Не передавать литералы в качестве локализованных параметров" Category="Microsoft.Globalization" CheckId="CA1303">
   <Name>Не передавать литералы в качестве локализованных параметров</Name>
   <Description>Строки литералов, внедренные в исходный код, сложно локализировать. Избегайте передачи строк типа литерал в качестве аргументов в случаях, когда ожидается локализованная строка.</Description>
   <Resolution Name="KnownValue">Метод {0} передает строку-литерал, как параметр "{1}" при вызове {2}. Вместо этого выполните поиск следующей строки (строк) в таблице источника: {3}.</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182187.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="16.0.0.0" />
  </Rule>
  <Rule TypeName="Проверить аргументы или открытые методы" Category="Microsoft.Design" CheckId="CA1062">
   <Name>Проверить аргументы или открытые методы</Name>
   <Description>Все аргументы ссылок, передаваемые внешним видимым методам должны проверяться на NULL (Nothing в VB). При необходимости вызывает исключение System.ArgumentNullException, если аргумент равен "null".</Description>
   <Resolution Name="Default">В видимом извне методе {0} проверьте параметр '{1}' перед его использованием.</Resolution>
   <Owner>RuleOwner</Owner>
   <Url>http://msdn.microsoft.com/library/ms182182.aspx</Url>
   <Email />
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="dataflowrules.dll" Version="16.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">Категория</String>
  <String Key="Certainty">Достоверность</String>
  <String Key="CollapseAll">Свернуть все</String>
  <String Key="CheckId">ИД проверки</String>
  <String Key="Error">Ошибка</String>
  <String Key="Errors">ошибки</String>
  <String Key="ExpandAll">Развернуть все</String>
  <String Key="Help">Справка</String>
  <String Key="Line">Строка</String>
  <String Key="Messages">сообщения</String>
  <String Key="LocationNotStoredInPdb">[расположение не сохранено в PDB]</String>
  <String Key="Project">Проект</String>
  <String Key="Resolution">Разрешение</String>
  <String Key="Rule">Правило</String>
  <String Key="RuleFile">Файл правил</String>
  <String Key="RuleDescription">Описание правила</String>
  <String Key="Source">Источник</String>
  <String Key="Status">Состояние</String>
  <String Key="Target">Цель</String>
  <String Key="Warning">Предупреждение</String>
  <String Key="Warnings">предупреждения</String>
  <String Key="ReportTitle">Отчет по Code Analysis</String>
 </Localized>
</FxCopReport>
